namespace Modern.CRDT.Services.Strategies;

using Modern.CRDT.Models;
using Modern.CRDT.Services.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.Json.Nodes;

public sealed class ArrayLcsStrategy : ICrdtStrategy
{
    private readonly IJsonNodeComparerProvider comparerProvider;

    /// <summary>
    /// Initializes a new instance of the <see cref="ArrayLcsStrategy"/> class.
    /// </summary>
    /// <param name="comparerProvider">The provider for resolving type-specific JSON node comparers.</param>
    public ArrayLcsStrategy(IJsonNodeComparerProvider comparerProvider)
    {
        this.comparerProvider = comparerProvider ?? throw new ArgumentNullException(nameof(comparerProvider));
    }

    /// <summary>
    /// Defines the type of difference operation in a Longest Common Subsequence (LCS) comparison.
    /// </summary>
    public enum LcsDiffEntryType { Match, Add, Remove }

    /// <summary>
    /// Represents a single entry in the difference list generated by the LCS algorithm.
    /// </summary>
    /// <param name="Type">The type of the difference operation (Match, Add, or Remove).</param>
    /// <param name="OldIndex">The index in the original array. -1 for an Add operation.</param>
    /// <param name="NewIndex">The index in the new array. -1 for a Remove operation.</param>
    public readonly record struct LcsDiffEntry(LcsDiffEntryType Type, int OldIndex, int NewIndex);
    
    public void GeneratePatch(IJsonCrdtPatcher patcher, List<CrdtOperation> operations, string path, PropertyInfo property, JsonNode? originalValue, JsonNode? modifiedValue, JsonNode? originalMetadata, JsonNode? modifiedMetadata)
    {
        var fromArray = originalValue?.AsArray() ?? new JsonArray();
        var toArray = modifiedValue?.AsArray() ?? new JsonArray();
        var fromMeta = originalMetadata?.AsArray();
        var toMeta = modifiedMetadata?.AsArray();

        var elementType = property.PropertyType.GetGenericArguments().FirstOrDefault() ?? property.PropertyType.GetElementType() ?? typeof(object);
        var comparer = comparerProvider.GetComparer(elementType);
        var diff = Diff(fromArray, toArray, comparer);

        var removeOps = new List<CrdtOperation>();
        var addOps = new List<CrdtOperation>();

        foreach (var entry in diff)
        {
            if (entry.Type == LcsDiffEntryType.Match)
            {
                var fromItem = fromArray[entry.OldIndex];
                var toItem = toArray[entry.NewIndex];
                
                if (!JsonNode.DeepEquals(fromItem, toItem) && fromItem is JsonObject fromObj && toItem is JsonObject toObj)
                {
                    if (elementType != typeof(object))
                    {
                        var itemPath = $"{path}[{entry.OldIndex}]";
                        var fromItemMeta = fromMeta is not null && entry.OldIndex < fromMeta.Count ? fromMeta[entry.OldIndex]?.AsObject() : null;
                        var toItemMeta = toMeta is not null && entry.NewIndex < toMeta.Count ? toMeta[entry.NewIndex]?.AsObject() : null;
                        patcher.DifferentiateObject(itemPath, elementType, fromObj, fromItemMeta, toObj, toItemMeta, operations);
                    }
                }
            }
            else if (entry.Type == LcsDiffEntryType.Add)
            {
                var addPath = $"{path}[{entry.NewIndex}]";
                var timestamp = toMeta is not null && entry.NewIndex < toMeta.Count ? GetTimestamp(toMeta[entry.NewIndex]) : DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
                addOps.Add(new CrdtOperation(addPath, OperationType.Upsert, toArray[entry.NewIndex]?.DeepClone(), timestamp));
            }
            else if (entry.Type == LcsDiffEntryType.Remove)
            {
                var removePath = $"{path}[{entry.OldIndex}]";
                var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(); // Timestamp for removes needs a source. Defaulting to now.
                removeOps.Add(new CrdtOperation(removePath, OperationType.Remove, null, timestamp));
            }
        }

        operations.AddRange(removeOps.OrderByDescending(op =>
        {
            var segments = JsonNodePathHelper.ParsePath(op.JsonPath);
            var lastSegment = segments.LastOrDefault();
            if (lastSegment is not null && int.TryParse(lastSegment, out var index))
            {
                return index;
            }
            return -1;
        }));
        
        operations.AddRange(addOps);
    }
    
    public void ApplyOperation(JsonNode rootNode, CrdtOperation operation)
    {
        ArgumentNullException.ThrowIfNull(rootNode);
        ArgumentNullException.ThrowIfNull(operation);

        var (dataParent, lastDataSegment) = JsonNodePathHelper.FindParentNode(rootNode, operation.JsonPath);

        if (dataParent is not JsonArray dataArray)
        {
            return;
        }

        if (!int.TryParse(lastDataSegment, out var arrayIndex))
        {
            return;
        }

        if (operation.Type == OperationType.Upsert)
        {
            if (arrayIndex <= dataArray.Count)
            {
                dataArray.Insert(arrayIndex, operation.Value?.DeepClone());
            }
        }
        else if (operation.Type == OperationType.Remove)
        {
            if (arrayIndex < dataArray.Count)
            {
                dataArray.RemoveAt(arrayIndex);
            }
        }
    }
    
    internal List<LcsDiffEntry> Diff(JsonArray from, JsonArray to, IEqualityComparer<JsonNode> itemComparer)
    {
        var n = from.Count;
        var m = to.Count;
        var dp = new int[n + 1, m + 1];

        for (var i = 1; i <= n; i++)
        {
            for (var j = 1; j <= m; j++)
            {
                if (itemComparer.Equals(from[i - 1], to[j - 1]))
                {
                    dp[i, j] = dp[i - 1, j - 1] + 1;
                }
                else
                {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }
        }

        var diff = new List<LcsDiffEntry>();
        var i_ptr = n;
        var j_ptr = m;
        while (i_ptr > 0 || j_ptr > 0)
        {
            if (i_ptr > 0 && j_ptr > 0 && itemComparer.Equals(from[i_ptr - 1], to[j_ptr - 1]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Match, i_ptr - 1, j_ptr - 1));
                i_ptr--;
                j_ptr--;
            }
            else if (j_ptr > 0 && (i_ptr == 0 || dp[i_ptr, j_ptr - 1] >= dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Add, -1, j_ptr - 1));
                j_ptr--;
            }
            else if (i_ptr > 0 && (j_ptr == 0 || dp[i_ptr, j_ptr - 1] < dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Remove, i_ptr - 1, -1));
                i_ptr--;
            }
        }

        diff.Reverse();
        return diff;
    }
    
    private static long GetTimestamp(JsonNode? metaNode)
    {
        return metaNode is JsonValue value && value.TryGetValue<long>(out var timestamp) ? timestamp : 0;
    }
}