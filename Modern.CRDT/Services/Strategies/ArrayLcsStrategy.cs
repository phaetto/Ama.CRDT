namespace Modern.CRDT.Services.Strategies;

using Microsoft.Extensions.Options;
using Modern.CRDT.Models;
using Modern.CRDT.Services.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.Json.Nodes;

public sealed class ArrayLcsStrategy : ICrdtStrategy
{
    private readonly IJsonNodeComparerProvider comparerProvider;
    private readonly ICrdtTimestampProvider timestampProvider;
    private readonly string replicaId;

    /// <summary>
    /// Initializes a new instance of the <see cref="ArrayLcsStrategy"/> class.
    /// </summary>
    /// <param name="comparerProvider">The provider for resolving type-specific JSON node comparers.</param>
    /// <param name="timestampProvider">The provider for generating timestamps.</param>
    /// <param name="options">Configuration options containing the replica ID.</param>
    public ArrayLcsStrategy(IJsonNodeComparerProvider comparerProvider, ICrdtTimestampProvider timestampProvider, IOptions<CrdtOptions> options)
    {
        this.comparerProvider = comparerProvider ?? throw new ArgumentNullException(nameof(comparerProvider));
        this.timestampProvider = timestampProvider ?? throw new ArgumentNullException(nameof(timestampProvider));
        ArgumentNullException.ThrowIfNull(options?.Value);
        this.replicaId = options.Value.ReplicaId;
    }

    /// <summary>
    /// Defines the type of difference operation in a Longest Common Subsequence (LCS) comparison.
    /// </summary>
    public enum LcsDiffEntryType { Match, Add, Remove }

    /// <summary>
    /// Represents a single entry in the difference list generated by the LCS algorithm.
    /// </summary>
    /// <param name="Type">The type of the difference operation (Match, Add, or Remove).</param>
    /// <param name="OldIndex">The index in the original array. -1 for an Add operation.</param>
    /// <param name="NewIndex">The index in the new array. -1 for a Remove operation.</param>
    public readonly record struct LcsDiffEntry(LcsDiffEntryType Type, int OldIndex, int NewIndex);
    
    public void GeneratePatch(IJsonCrdtPatcher patcher, List<CrdtOperation> operations, string path, PropertyInfo property, JsonNode? originalValue, JsonNode? modifiedValue, JsonNode? originalMetadata, JsonNode? modifiedMetadata)
    {
        var fromArray = originalValue?.AsArray() ?? new JsonArray();
        var toArray = modifiedValue?.AsArray() ?? new JsonArray();
        var fromMeta = originalMetadata?.AsArray();
        var toMeta = modifiedMetadata?.AsArray();

        var elementType = property.PropertyType.GetGenericArguments().FirstOrDefault() ?? property.PropertyType.GetElementType() ?? typeof(object);
        var comparer = comparerProvider.GetComparer(elementType);
        var diff = Diff(fromArray, toArray, comparer);

        var removeOps = new List<CrdtOperation>();
        var addOps = new List<CrdtOperation>();

        foreach (var entry in diff)
        {
            if (entry.Type == LcsDiffEntryType.Match)
            {
                var fromItem = fromArray[entry.OldIndex];
                var toItem = toArray[entry.NewIndex];
                
                if (!JsonNode.DeepEquals(fromItem, toItem) && fromItem is JsonObject fromObj && toItem is JsonObject toObj)
                {
                    if (elementType != typeof(object))
                    {
                        var itemPath = $"{path}[{entry.OldIndex}]";
                        var fromItemMeta = fromMeta is not null && entry.OldIndex < fromMeta.Count ? fromMeta[entry.OldIndex]?.AsObject() : null;
                        var toItemMeta = toMeta is not null && entry.NewIndex < toMeta.Count ? toMeta[entry.NewIndex]?.AsObject() : null;
                        patcher.DifferentiateObject(itemPath, elementType, fromObj, fromItemMeta, toObj, toItemMeta, operations);
                    }
                }
            }
            else if (entry.Type == LcsDiffEntryType.Add)
            {
                var addPath = $"{path}[{entry.NewIndex}]";
                var timestampNode = toMeta is not null && entry.NewIndex < toMeta.Count ? toMeta[entry.NewIndex] : null;
                var timestamp = GetTimestamp(timestampNode);
                if (timestamp.CompareTo(EpochTimestamp.MinValue) == 0)
                {
                    timestamp = timestampProvider.Now();
                }
                addOps.Add(new CrdtOperation(Guid.NewGuid(), replicaId, addPath, OperationType.Upsert, toArray[entry.NewIndex]?.DeepClone(), timestamp));
            }
            else if (entry.Type == LcsDiffEntryType.Remove)
            {
                var removePath = $"{path}[{entry.OldIndex}]";
                var timestamp = timestampProvider.Now();
                var removedItem = fromArray[entry.OldIndex];
                removeOps.Add(new CrdtOperation(Guid.NewGuid(), replicaId, removePath, OperationType.Remove, removedItem?.DeepClone(), timestamp));
            }
        }

        operations.AddRange(removeOps.OrderByDescending(op =>
        {
            var segments = JsonNodePathHelper.ParsePath(op.JsonPath);
            var lastSegment = segments.LastOrDefault();
            if (lastSegment is not null && int.TryParse(lastSegment, out var index))
            {
                return index;
            }
            return -1;
        }));
        
        operations.AddRange(addOps);
    }
    
    public void ApplyOperation(JsonNode rootNode, CrdtOperation operation, PropertyInfo property)
    {
        ArgumentNullException.ThrowIfNull(rootNode);
        ArgumentNullException.ThrowIfNull(property);

        // For an array operation, the path points to an element, so we need the parent path to find the array itself.
        var (parentPath, _) = JsonNodePathHelper.SplitPath(operation.JsonPath);
        if (parentPath is null)
        {
            return;
        }

        var (dataParent, lastDataSegment) = JsonNodePathHelper.FindParentNode(rootNode, parentPath);
        if (dataParent?[lastDataSegment] is not JsonArray dataArray)
        {
            return;
        }
        
        var elementType = property.PropertyType.GetGenericArguments().FirstOrDefault() ?? property.PropertyType.GetElementType() ?? typeof(object);
        var comparer = comparerProvider.GetComparer(elementType);

        if (operation.Type == OperationType.Upsert)
        {
            var newValue = operation.Value?.DeepClone();
            if (newValue is null) return;
            
            var existingIndex = -1;
            for (var i = 0; i < dataArray.Count; i++)
            {
                if (comparer.Equals(dataArray[i], newValue))
                {
                    existingIndex = i;
                    break;
                }
            }

            if (existingIndex != -1)
            {
                dataArray[existingIndex] = newValue;
            }
            else
            {
                dataArray.Add(newValue);
            }
            
            SortJsonArray(dataArray);
        }
        else if (operation.Type == OperationType.Remove)
        {
            var itemToRemove = operation.Value;
            if (itemToRemove is null) return;

            var indexToRemove = -1;
            for (var i = 0; i < dataArray.Count; i++)
            {
                if (comparer.Equals(dataArray[i], itemToRemove))
                {
                    indexToRemove = i;
                    break;
                }
            }

            if (indexToRemove != -1)
            {
                dataArray.RemoveAt(indexToRemove);
            }
        }
    }
    
    internal List<LcsDiffEntry> Diff(JsonArray from, JsonArray to, IEqualityComparer<JsonNode> itemComparer)
    {
        var n = from.Count;
        var m = to.Count;
        var dp = new int[n + 1, m + 1];

        for (var i = 1; i <= n; i++)
        {
            for (var j = 1; j <= m; j++)
            {
                if (itemComparer.Equals(from[i - 1], to[j - 1]))
                {
                    dp[i, j] = dp[i - 1, j - 1] + 1;
                }
                else
                {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }
        }

        var diff = new List<LcsDiffEntry>();
        var i_ptr = n;
        var j_ptr = m;
        while (i_ptr > 0 || j_ptr > 0)
        {
            if (i_ptr > 0 && j_ptr > 0 && itemComparer.Equals(from[i_ptr - 1], to[j_ptr - 1]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Match, i_ptr - 1, j_ptr - 1));
                i_ptr--;
                j_ptr--;
            }
            else if (j_ptr > 0 && (i_ptr == 0 || dp[i_ptr, j_ptr - 1] >= dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Add, -1, j_ptr - 1));
                j_ptr--;
            }
            else if (i_ptr > 0 && (j_ptr == 0 || dp[i_ptr, j_ptr - 1] < dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Remove, i_ptr - 1, -1));
                i_ptr--;
            }
        }

        diff.Reverse();
        return diff;
    }
    
    private static ICrdtTimestamp GetTimestamp(JsonNode? metaNode)
    {
        if (metaNode is JsonValue value && value.TryGetValue<long>(out var timestamp))
        {
            return new EpochTimestamp(timestamp);
        }
        return EpochTimestamp.MinValue;
    }

    private static void SortJsonArray(JsonArray jsonArray)
    {
        var items = jsonArray.ToList();
        jsonArray.Clear();

        items.Sort((x, y) =>
        {
            var keyX = GetSortKey(x);
            var keyY = GetSortKey(y);
            return string.Compare(keyX, keyY, StringComparison.Ordinal);
        });

        foreach (var item in items)
        {
            jsonArray.Add(item);
        }
    }

    private static string GetSortKey(JsonNode? node)
    {
        if (node is JsonObject obj)
        {
            if (obj.TryGetPropertyValue("id", out var idNode) && idNode is not null)
            {
                return idNode.ToString();
            }
            if (obj.TryGetPropertyValue("Id", out var idNodeUpper) && idNodeUpper is not null)
            {
                return idNodeUpper.ToString();
            }
        }
        
        return node?.ToJsonString() ?? string.Empty;
    }
}