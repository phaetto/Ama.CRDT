namespace Modern.CRDT.Services.Strategies;

using Modern.CRDT.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;

public sealed class ArrayLcsStrategy : ICrdtStrategy
{
    private static readonly Regex PathRegex = new(@"\.([^.\[\]]+)|\[(\d+)\]", RegexOptions.Compiled);
    private readonly IEqualityComparer<JsonNode> itemComparer;

    /// <summary>
    /// Initializes a new instance of the <see cref="ArrayLcsStrategy"/> class with the default deep equality comparer for JSON nodes.
    /// </summary>
    public ArrayLcsStrategy()
        : this(JsonNodeDeepEqualityComparer.Instance)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ArrayLcsStrategy"/> class with a custom equality comparer for JSON nodes.
    /// </summary>
    /// <param name="itemComparer">The custom equality comparer to use for matching items within arrays.</param>
    public ArrayLcsStrategy(IEqualityComparer<JsonNode> itemComparer)
    {
        this.itemComparer = itemComparer ?? throw new ArgumentNullException(nameof(itemComparer));
    }

    /// <summary>
    /// Defines the type of difference operation in a Longest Common Subsequence (LCS) comparison.
    /// </summary>
    public enum LcsDiffEntryType { Match, Add, Remove }

    /// <summary>
    /// Represents a single entry in the difference list generated by the LCS algorithm.
    /// </summary>
    /// <param name="Type">The type of the difference operation (Match, Add, or Remove).</param>
    /// <param name="OldIndex">The index in the original array. -1 for an Add operation.</param>
    /// <param name="NewIndex">The index in the new array. -1 for a Remove operation.</param>
    public readonly record struct LcsDiffEntry(LcsDiffEntryType Type, int OldIndex, int NewIndex);
    
    public void GeneratePatch(IJsonCrdtPatcher patcher, List<CrdtOperation> operations, string path, PropertyInfo property, JsonNode? originalValue, JsonNode? modifiedValue, JsonNode? originalMetadata, JsonNode? modifiedMetadata)
    {
        var fromArray = originalValue?.AsArray() ?? new JsonArray();
        var toArray = modifiedValue?.AsArray() ?? new JsonArray();
        var fromMeta = originalMetadata?.AsArray();
        var toMeta = modifiedMetadata?.AsArray();

        var diff = Diff(fromArray, toArray);

        var removeOps = new List<CrdtOperation>();
        var addOps = new List<CrdtOperation>();

        foreach (var entry in diff)
        {
            if (entry.Type == LcsDiffEntryType.Match)
            {
                var fromItem = fromArray[entry.OldIndex];
                var toItem = toArray[entry.NewIndex];
                
                if (!JsonNode.DeepEquals(fromItem, toItem) && fromItem is JsonObject fromObj && toItem is JsonObject toObj)
                {
                    var elementType = property.PropertyType.GetGenericArguments().FirstOrDefault() ?? property.PropertyType.GetElementType();
                    if (elementType is not null)
                    {
                        var itemPath = $"{path}[{entry.OldIndex}]";
                        var fromItemMeta = fromMeta is not null && entry.OldIndex < fromMeta.Count ? fromMeta[entry.OldIndex]?.AsObject() : null;
                        var toItemMeta = toMeta is not null && entry.NewIndex < toMeta.Count ? toMeta[entry.NewIndex]?.AsObject() : null;
                        patcher.DifferentiateObject(itemPath, elementType, fromObj, fromItemMeta, toObj, toItemMeta, operations);
                    }
                }
            }
            else if (entry.Type == LcsDiffEntryType.Add)
            {
                var addPath = $"{path}[{entry.NewIndex}]";
                var timestamp = toMeta is not null && entry.NewIndex < toMeta.Count ? GetTimestamp(toMeta[entry.NewIndex]) : DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
                addOps.Add(new CrdtOperation(addPath, OperationType.Upsert, toArray[entry.NewIndex]?.DeepClone(), timestamp));
            }
            else if (entry.Type == LcsDiffEntryType.Remove)
            {
                var removePath = $"{path}[{entry.OldIndex}]";
                var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(); // Timestamp for removes needs a source. Defaulting to now.
                removeOps.Add(new CrdtOperation(removePath, OperationType.Remove, null, timestamp));
            }
        }

        operations.AddRange(removeOps.OrderByDescending(op =>
        {
            var lastMatch = PathRegex.Matches(op.JsonPath).Cast<Match>().LastOrDefault();
            if (lastMatch is null || !lastMatch.Groups[2].Success)
            {
                return -1;
            }
            return int.Parse(lastMatch.Groups[2].Value);
        }));
        
        operations.AddRange(addOps);
    }
    
    public void ApplyOperation(JsonNode rootNode, JsonNode metadataNode, CrdtOperation operation)
    {
        var (dataParent, lastDataSegment) = FindParent(rootNode, operation.JsonPath);
        var (metaParent, _) = FindParent(metadataNode, operation.JsonPath);

        if (dataParent is not JsonArray dataArray || metaParent is not JsonArray metaArray)
        {
            return;
        }

        if (!int.TryParse(lastDataSegment, out var arrayIndex))
        {
            return;
        }

        if (operation.Type == OperationType.Upsert)
        {
            if (arrayIndex <= dataArray.Count)
            {
                dataArray.Insert(arrayIndex, operation.Value?.DeepClone());
                metaArray.Insert(arrayIndex, JsonValue.Create(operation.Timestamp));
            }
        }
        else if (operation.Type == OperationType.Remove)
        {
            if (arrayIndex < dataArray.Count)
            {
                dataArray.RemoveAt(arrayIndex);
                metaArray.RemoveAt(arrayIndex);
            }
        }
    }
    
    internal List<LcsDiffEntry> Diff(JsonArray from, JsonArray to)
    {
        var n = from.Count;
        var m = to.Count;
        var dp = new int[n + 1, m + 1];

        for (var i = 1; i <= n; i++)
        {
            for (var j = 1; j <= m; j++)
            {
                if (itemComparer.Equals(from[i - 1], to[j - 1]))
                {
                    dp[i, j] = dp[i - 1, j - 1] + 1;
                }
                else
                {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }
        }

        var diff = new List<LcsDiffEntry>();
        var i_ptr = n;
        var j_ptr = m;
        while (i_ptr > 0 || j_ptr > 0)
        {
            if (i_ptr > 0 && j_ptr > 0 && itemComparer.Equals(from[i_ptr - 1], to[j_ptr - 1]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Match, i_ptr - 1, j_ptr - 1));
                i_ptr--;
                j_ptr--;
            }
            else if (j_ptr > 0 && (i_ptr == 0 || dp[i_ptr, j_ptr - 1] >= dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Add, -1, j_ptr - 1));
                j_ptr--;
            }
            else if (i_ptr > 0 && (j_ptr == 0 || dp[i_ptr, j_ptr - 1] < dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Remove, i_ptr - 1, -1));
                i_ptr--;
            }
        }

        diff.Reverse();
        return diff;
    }
    
    private static (JsonNode?, string) FindParent(JsonNode? root, string jsonPath)
    {
        if (root is null || string.IsNullOrWhiteSpace(jsonPath) || jsonPath == "$")
        {
            return (root, string.Empty);
        }

        var segments = ParsePath(jsonPath);
        if (segments.Count == 0)
        {
            return (root, string.Empty);
        }

        JsonNode? currentNode = root;
        for (var i = 0; i < segments.Count - 1; i++)
        {
            var segment = segments[i];
            if (currentNode is null) return (null, string.Empty);

            if (int.TryParse(segment, out var index))
            {
                currentNode = currentNode is JsonArray arr && arr.Count > index ? arr[index] : null;
            }
            else
            {
                currentNode = currentNode is JsonObject obj && obj.TryGetPropertyValue(segment, out var node) ? node : null;
            }
        }

        return (currentNode, segments.Last());
    }

    private static List<string> ParsePath(string jsonPath)
    {
        var segments = new List<string>();
        if (string.IsNullOrWhiteSpace(jsonPath) || jsonPath == "$") return segments;
        
        var matches = PathRegex.Matches(jsonPath);
        foreach (Match match in matches.Cast<Match>())
        {
            segments.Add(match.Groups[1].Success ? match.Groups[1].Value : match.Groups[2].Value);
        }
        return segments;
    }
    
    private static long GetTimestamp(JsonNode? metaNode)
    {
        return metaNode is JsonValue value && value.TryGetValue<long>(out var timestamp) ? timestamp : 0;
    }
    
    public sealed class JsonNodeDeepEqualityComparer : IEqualityComparer<JsonNode>
    {
        public static readonly JsonNodeDeepEqualityComparer Instance = new();

        public bool Equals(JsonNode? x, JsonNode? y)
        {
            return JsonNode.DeepEquals(x, y);
        }

        public int GetHashCode(JsonNode obj)
        {
            if (obj is null)
            {
                return 0;
            }
            
            return obj.ToJsonString().GetHashCode();
        }
    }
}