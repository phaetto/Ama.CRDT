namespace Ama.CRDT.Services.Strategies;

using Ama.CRDT.Attributes;
using Ama.CRDT.Attributes.Strategies;
using Ama.CRDT.Models;
using Ama.CRDT.Services;
using Microsoft.Extensions.Options;
using Ama.CRDT.Services.Helpers;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.Json;
using Ama.CRDT.Services.Providers;

/// <inheritdoc/>
[CrdtSupportedType(typeof(IEnumerable))]
[Commutative]
[Associative]
[Idempotent]
[SequentialOperations]
public sealed class SortedSetStrategy : ICrdtStrategy
{
    private readonly IElementComparerProvider comparerProvider;
    private readonly ICrdtTimestampProvider timestampProvider;
    private readonly string replicaId;

    /// <summary>
    /// Initializes a new instance of the <see cref="SortedSetStrategy"/> class.
    /// </summary>
    /// <param name="comparerProvider">The provider for resolving type-specific element comparers.</param>
    /// <param name="timestampProvider">The provider for generating timestamps.</param>
    /// <param name="options">Configuration options containing the replica ID.</param>
    public SortedSetStrategy(IElementComparerProvider comparerProvider, ICrdtTimestampProvider timestampProvider, IOptions<CrdtOptions> options)
    {
        this.comparerProvider = comparerProvider ?? throw new ArgumentNullException(nameof(comparerProvider));
        this.timestampProvider = timestampProvider ?? throw new ArgumentNullException(nameof(timestampProvider));
        ArgumentNullException.ThrowIfNull(options?.Value);
        replicaId = options.Value.ReplicaId;
    }

    /// <summary>
    /// Defines the type of difference operation in a Longest Common Subsequence (LCS) comparison.
    /// </summary>
    public enum LcsDiffEntryType { 
        /// <summary>
        /// Element matched
        /// </summary>
        Match,
        /// <summary>
        /// Element Added
        /// </summary>
        Add,
        /// <summary>
        /// Element removed
        /// </summary>
        Remove
    }

    /// <summary>
    /// Represents a single entry in the difference list generated by the LCS algorithm.
    /// </summary>
    /// <param name="Type">The type of the difference operation (Match, Add, or Remove).</param>
    /// <param name="OldIndex">The index in the original array. -1 for an Add operation.</param>
    /// <param name="NewIndex">The index in the new array. -1 for a Remove operation.</param>
    public readonly record struct LcsDiffEntry(LcsDiffEntryType Type, int OldIndex, int NewIndex);
    
    /// <inheritdoc/>
    public void GeneratePatch([DisallowNull] ICrdtPatcher patcher, [DisallowNull] List<CrdtOperation> operations, [DisallowNull] string path, [DisallowNull] PropertyInfo property, object? originalValue, object? modifiedValue, object? originalRoot, object? modifiedRoot, [DisallowNull] CrdtMetadata originalMeta, [DisallowNull] CrdtMetadata modifiedMeta)
    {
        var fromArray = (originalValue as IEnumerable)?.Cast<object>().ToList() ?? new List<object>();
        var toArray = (modifiedValue as IEnumerable)?.Cast<object>().ToList() ?? new List<object>();

        var elementType = property.PropertyType.GetGenericArguments().FirstOrDefault() ?? property.PropertyType.GetElementType() ?? typeof(object);
        var comparer = comparerProvider.GetComparer(elementType);
        
        var diff = Diff(fromArray, toArray, comparer);

        var removeOps = new List<CrdtOperation>();
        var addOps = new List<CrdtOperation>();

        foreach (var entry in diff)
        {
            if (entry.Type == LcsDiffEntryType.Match)
            {
                var fromItem = fromArray[entry.OldIndex];
                var toItem = toArray[entry.NewIndex];
                
                if (!Equals(fromItem, toItem))
                {
                    var itemPath = $"{path}[{entry.OldIndex}]";
                    patcher.DifferentiateObject(itemPath, elementType, fromItem, originalMeta, toItem, modifiedMeta, operations, originalRoot, modifiedRoot);
                }
            }
            else if (entry.Type == LcsDiffEntryType.Add)
            {
                var addPath = $"{path}[{entry.NewIndex}]";
                var timestamp = timestampProvider.Now();
                var addedItem = toArray[entry.NewIndex];
                addOps.Add(new CrdtOperation(Guid.NewGuid(), replicaId, addPath, OperationType.Upsert, addedItem, timestamp));
            }
            else if (entry.Type == LcsDiffEntryType.Remove)
            {
                var removePath = $"{path}[{entry.OldIndex}]";
                var timestamp = timestampProvider.Now();
                var removedItem = fromArray[entry.OldIndex];
                removeOps.Add(new CrdtOperation(Guid.NewGuid(), replicaId, removePath, OperationType.Remove, removedItem, timestamp));
            }
        }

        operations.AddRange(removeOps);
        operations.AddRange(addOps);
    }
    
    /// <inheritdoc/>
    public void ApplyOperation([DisallowNull] object root, [DisallowNull] CrdtMetadata metadata, CrdtOperation operation)
    {
        ArgumentNullException.ThrowIfNull(root);
        ArgumentNullException.ThrowIfNull(metadata);

        var lastBracket = operation.JsonPath.LastIndexOf('[');
        if (lastBracket <= 0 || !operation.JsonPath.EndsWith("]"))
        {
            return;
        }

        var collectionPath = operation.JsonPath[..lastBracket];
        var (parent, property, _) = PocoPathHelper.ResolvePath(root, collectionPath);

        if (parent is null || property is null)
        {
            return;
        }

        if (property.GetValue(parent) is not IList list)
        {
            return;
        }

        Type? elementType = null;
        var propType = property.PropertyType;
        if (propType.IsGenericType)
        {
            elementType = propType.GetGenericArguments().FirstOrDefault();
        }

        if (elementType is null)
        {
            var listType = list.GetType();
            elementType = listType.IsGenericType
                ? listType.GetGenericArguments().FirstOrDefault()
                : listType.GetElementType();
        }

        elementType ??= typeof(object);

        var comparer = comparerProvider.GetComparer(elementType);

        if (operation.Type == OperationType.Upsert)
        {
            var newValue = DeserializeValue(operation.Value, elementType);
            if (newValue is null) return;

            var existingIndex = -1;
            for (var i = 0; i < list.Count; i++)
            {
                if (comparer.Equals(list[i], newValue))
                {
                    existingIndex = i;
                    break;
                }
            }

            if (existingIndex != -1)
            {
                list[existingIndex] = newValue;
            }
            else
            {
                list.Add(newValue);
            }

            SortList(list);
        }
        else if (operation.Type == OperationType.Remove)
        {
            if (operation.Value is null) return;
            var valueToRemove = DeserializeValue(operation.Value, elementType);
            if (valueToRemove is null) return;

            var indexToRemove = -1;
            for (var i = 0; i < list.Count; i++)
            {
                if (comparer.Equals(list[i], valueToRemove))
                {
                    indexToRemove = i;
                    break;
                }
            }

            if (indexToRemove != -1)
            {
                list.RemoveAt(indexToRemove);
            }
        }
    }
    
    internal List<LcsDiffEntry> Diff(List<object> from, List<object> to, IEqualityComparer<object> itemComparer)
    {
        var n = from.Count;
        var m = to.Count;
        var dp = new int[n + 1, m + 1];

        for (var i = 1; i <= n; i++)
        {
            for (var j = 1; j <= m; j++)
            {
                if (itemComparer.Equals(from[i-1], to[j-1]))
                {
                    dp[i, j] = dp[i - 1, j - 1] + 1;
                }
                else
                {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }
        }

        var diff = new List<LcsDiffEntry>();
        var i_ptr = n;
        var j_ptr = m;
        while (i_ptr > 0 || j_ptr > 0)
        {
            if (i_ptr > 0 && j_ptr > 0 && itemComparer.Equals(from[i_ptr - 1], to[j_ptr - 1]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Match, i_ptr - 1, j_ptr - 1));
                i_ptr--;
                j_ptr--;
            }
            else if (j_ptr > 0 && (i_ptr == 0 || dp[i_ptr, j_ptr - 1] >= dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Add, -1, j_ptr - 1));
                j_ptr--;
            }
            else if (i_ptr > 0 && (j_ptr == 0 || dp[i_ptr, j_ptr - 1] < dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Remove, i_ptr - 1, -1));
                i_ptr--;
            }
        }

        diff.Reverse();
        return diff;
    }
    
    private static void SortList(IList list)
    {
        var items = new List<object>();
        foreach (var item in list)
        {
            items.Add(item);
        }
        
        items.Sort((x, y) =>
        {
            var keyX = GetSortKey(x);
            var keyY = GetSortKey(y);
            return string.Compare(keyX, keyY, StringComparison.Ordinal);
        });
        
        list.Clear();
        foreach (var item in items)
        {
            list.Add(item);
        }
    }

    private static string GetSortKey(object? obj)
    {
        if (obj is null)
        {
            return string.Empty;
        }

        var type = obj.GetType();
        var idProp = type.GetProperty("Id", BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance);

        if (idProp is not null)
        {
            return idProp.GetValue(obj)?.ToString() ?? string.Empty;
        }

        if (type.IsClass && type != typeof(string))
        {
            var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .Where(p => p.CanRead)
                .OrderBy(p => p.Name);
            
            var keyBuilder = new StringBuilder();
            foreach (var prop in properties)
            {
                keyBuilder.Append(prop.GetValue(obj)?.ToString() ?? "null");
                keyBuilder.Append('|');
            }
            return keyBuilder.ToString();
        }

        return obj.ToString() ?? string.Empty;
    }
    
    private static object? DeserializeValue(object? value, Type targetType)
    {
        if (value is null)
        {
            return null;
        }

        if (targetType.IsInstanceOfType(value))
        {
            return value;
        }

        if (value is JsonElement jsonElement)
        {
            return jsonElement.Deserialize(targetType, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
        }

        var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;

        if (value is IConvertible)
        {
            try
            {
                return Convert.ChangeType(value, underlyingType, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is InvalidCastException || ex is FormatException || ex is OverflowException)
            {
                // Fall through to dictionary mapping logic.
            }
        }

        if (value is IDictionary<string, object> dictionary && !underlyingType.IsPrimitive && underlyingType != typeof(string))
        {
            var instance = Activator.CreateInstance(underlyingType);
            if (instance is null)
            {
                return null;
            }

            var properties = underlyingType.GetProperties(BindingFlags.Public | BindingFlags.Instance).Where(p => p.CanWrite);

            foreach (var property in properties)
            {
                var key = dictionary.Keys.FirstOrDefault(k => string.Equals(k, property.Name, StringComparison.OrdinalIgnoreCase));
                if (key != null)
                {
                    var propValue = dictionary[key];
                    property.SetValue(instance, DeserializeValue(propValue, property.PropertyType));
                }
            }
            return instance;
        }
        
        return PocoPathHelper.ConvertValue(value, targetType);
    }
}