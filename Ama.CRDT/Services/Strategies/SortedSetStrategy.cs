namespace Ama.CRDT.Services.Strategies;

using Ama.CRDT.Attributes;
using Ama.CRDT.Attributes.Strategies;
using Ama.CRDT.Models;
using Ama.CRDT.Services;
using Ama.CRDT.Services.Helpers;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.Json;
using Ama.CRDT.Services.Providers;

/// <summary>
/// Implements a CRDT strategy for collections that are treated as sorted sets. It uses the Longest Common Subsequence (LCS) algorithm to find differences and ensures the collection remains sorted after operations.
/// This strategy assumes elements can be uniquely identified and compared. For complex objects, sorting is based on an 'Id' property or a composite key of all properties if 'Id' is not present.
/// </summary>
[CrdtSupportedType(typeof(IList))]
[Commutative]
[Associative]
[Idempotent]
[SequentialOperations]
public sealed class SortedSetStrategy(
    IElementComparerProvider comparerProvider, 
    ReplicaContext replicaContext) : ICrdtStrategy
{
    private readonly string replicaId = replicaContext.ReplicaId;

    /// <summary>
    /// Defines the type of difference operation in a Longest Common Subsequence (LCS) comparison.
    /// </summary>
    public enum LcsDiffEntryType { 
        /// <summary>
        /// Indicates that an element was found in both the original and modified collections.
        /// </summary>
        Match,
        /// <summary>
        /// Indicates that an element was added to the modified collection.
        /// </summary>
        Add,
        /// <summary>
        /// Indicates that an element was removed from the original collection.
        /// </summary>
        Remove
    }

    /// <summary>
    /// Represents a single entry in the difference list generated by the LCS algorithm, detailing a match, addition, or removal.
    /// </summary>
    /// <param name="Type">The type of the difference operation (<see cref="LcsDiffEntryType.Match"/>, <see cref="LcsDiffEntryType.Add"/>, or <see cref="LcsDiffEntryType.Remove"/>).</param>
    /// <param name="OldIndex">The index of the element in the original collection. This is -1 for an <see cref="LcsDiffEntryType.Add"/> operation.</param>
    /// <param name="NewIndex">The index of the element in the modified collection. This is -1 for a <see cref="LcsDiffEntryType.Remove"/> operation.</param>
    public readonly record struct LcsDiffEntry(LcsDiffEntryType Type, int OldIndex, int NewIndex);
    
    /// <inheritdoc/>
    public void GeneratePatch(GeneratePatchContext context)
    {
        var (patcher, operations, path, property, originalValue, modifiedValue, originalRoot, modifiedRoot, originalMeta, changeTimestamp) = context;

        var fromArray = (originalValue as IEnumerable)?.Cast<object>().ToList() ?? new List<object>();
        var toArray = (modifiedValue as IEnumerable)?.Cast<object>().ToList() ?? new List<object>();

        var elementType = PocoPathHelper.GetCollectionElementType(property);
        var comparer = comparerProvider.GetComparer(elementType);
        
        var diff = Diff(fromArray, toArray, comparer);

        var removeOps = new List<CrdtOperation>();
        var addOps = new List<CrdtOperation>();

        foreach (var entry in diff)
        {
            if (entry.Type == LcsDiffEntryType.Match)
            {
                var fromItem = fromArray[entry.OldIndex];
                var toItem = toArray[entry.NewIndex];
                
                if (!Equals(fromItem, toItem))
                {
                    var itemPath = $"{path}[{entry.OldIndex}]";
                    var diffContext = new DifferentiateObjectContext(itemPath, elementType, fromItem, toItem, originalRoot, modifiedRoot, originalMeta, operations, changeTimestamp);
                    patcher.DifferentiateObject(diffContext);
                }
            }
            else if (entry.Type == LcsDiffEntryType.Add)
            {
                var addPath = $"{path}[{entry.NewIndex}]";
                var addedItem = toArray[entry.NewIndex];
                addOps.Add(new CrdtOperation(Guid.NewGuid(), replicaId, addPath, OperationType.Upsert, addedItem, changeTimestamp));
            }
            else if (entry.Type == LcsDiffEntryType.Remove)
            {
                var removePath = $"{path}[{entry.OldIndex}]";
                var removedItem = fromArray[entry.OldIndex];
                removeOps.Add(new CrdtOperation(Guid.NewGuid(), replicaId, removePath, OperationType.Remove, removedItem, changeTimestamp));
            }
        }

        operations.AddRange(removeOps);
        operations.AddRange(addOps);
    }
    
    /// <inheritdoc/>
    public void ApplyOperation(ApplyOperationContext context)
    {
        var (root, metadata, operation) = context;

        var lastBracket = operation.JsonPath.LastIndexOf('[');
        if (lastBracket <= 0 || !operation.JsonPath.EndsWith("]"))
        {
            return;
        }

        var collectionPath = operation.JsonPath[..lastBracket];
        var (parent, property, _) = PocoPathHelper.ResolvePath(root, collectionPath);

        if (parent is null || property is null)
        {
            return;
        }

        if (property.GetValue(parent) is not IList list)
        {
            return;
        }

        var elementType = PocoPathHelper.GetCollectionElementType(property);
        var comparer = comparerProvider.GetComparer(elementType);

        if (operation.Type == OperationType.Upsert)
        {
            var newValue = DeserializeValue(operation.Value, elementType);
            if (newValue is null) return;

            var existingIndex = -1;
            for (var i = 0; i < list.Count; i++)
            {
                if (comparer.Equals(list[i], newValue))
                {
                    existingIndex = i;
                    break;
                }
            }

            if (existingIndex != -1)
            {
                list[existingIndex] = newValue;
            }
            else
            {
                list.Add(newValue);
            }

            SortList(list);
        }
        else if (operation.Type == OperationType.Remove)
        {
            if (operation.Value is null) return;
            var valueToRemove = DeserializeValue(operation.Value, elementType);
            if (valueToRemove is null) return;

            var indexToRemove = -1;
            for (var i = 0; i < list.Count; i++)
            {
                if (comparer.Equals(list[i], valueToRemove))
                {
                    indexToRemove = i;
                    break;
                }
            }

            if (indexToRemove != -1)
            {
                list.RemoveAt(indexToRemove);
            }
        }
    }
    
    internal List<LcsDiffEntry> Diff(List<object> from, List<object> to, IEqualityComparer<object> itemComparer)
    {
        var n = from.Count;
        var m = to.Count;
        var dp = new int[n + 1, m + 1];

        for (var i = 1; i <= n; i++)
        {
            for (var j = 1; j <= m; j++)
            {
                if (itemComparer.Equals(from[i-1], to[j-1]))
                {
                    dp[i, j] = dp[i - 1, j - 1] + 1;
                }
                else
                {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }
        }

        var diff = new List<LcsDiffEntry>();
        var i_ptr = n;
        var j_ptr = m;
        while (i_ptr > 0 || j_ptr > 0)
        {
            if (i_ptr > 0 && j_ptr > 0 && itemComparer.Equals(from[i_ptr - 1], to[j_ptr - 1]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Match, i_ptr - 1, j_ptr - 1));
                i_ptr--;
                j_ptr--;
            }
            else if (j_ptr > 0 && (i_ptr == 0 || dp[i_ptr, j_ptr - 1] >= dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Add, -1, j_ptr - 1));
                j_ptr--;
            }
            else if (i_ptr > 0 && (j_ptr == 0 || dp[i_ptr, j_ptr - 1] < dp[i_ptr - 1, j_ptr]))
            {
                diff.Add(new LcsDiffEntry(LcsDiffEntryType.Remove, i_ptr - 1, -1));
                i_ptr--;
            }
        }

        diff.Reverse();
        return diff;
    }
    
    private static void SortList(IList list)
    {
        var items = new List<object>();
        foreach (var item in list)
        {
            items.Add(item);
        }
        
        items.Sort((x, y) =>
        {
            var keyX = GetSortKey(x);
            var keyY = GetSortKey(y);
            return string.Compare(keyX, keyY, StringComparison.Ordinal);
        });
        
        list.Clear();
        foreach (var item in items)
        {
            list.Add(item);
        }
    }

    private static string GetSortKey(object? obj)
    {
        if (obj is null)
        {
            return string.Empty;
        }

        var type = obj.GetType();
        var idProp = type.GetProperty("Id", BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance);

        if (idProp is not null)
        {
            return idProp.GetValue(obj)?.ToString() ?? string.Empty;
        }

        if (type.IsClass && type != typeof(string))
        {
            var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .Where(p => p.CanRead)
                .OrderBy(p => p.Name);
            
            var keyBuilder = new StringBuilder();
            foreach (var prop in properties)
            {
                keyBuilder.Append(prop.GetValue(obj)?.ToString() ?? "null");
                keyBuilder.Append('|');
            }
            return keyBuilder.ToString();
        }

        return obj.ToString() ?? string.Empty;
    }
    
    private static object? DeserializeValue(object? value, Type targetType)
    {
        if (value is null)
        {
            return null;
        }

        if (targetType.IsInstanceOfType(value))
        {
            return value;
        }

        if (value is JsonElement jsonElement)
        {
            return jsonElement.Deserialize(targetType, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
        }

        var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;

        if (value is IConvertible)
        {
            try
            {
                return Convert.ChangeType(value, underlyingType, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is InvalidCastException || ex is FormatException || ex is OverflowException)
            {
                // Fall through to dictionary mapping logic.
            }
        }

        if (value is IDictionary<string, object> dictionary && !underlyingType.IsPrimitive && underlyingType != typeof(string))
        {
            var instance = Activator.CreateInstance(underlyingType);
            if (instance is null)
            {
                return null;
            }

            var properties = underlyingType.GetProperties(BindingFlags.Public | BindingFlags.Instance).Where(p => p.CanWrite);

            foreach (var property in properties)
            {
                var key = dictionary.Keys.FirstOrDefault(k => string.Equals(k, property.Name, StringComparison.OrdinalIgnoreCase));
                if (key != null)
                {
                    var propValue = dictionary[key];
                    property.SetValue(instance, DeserializeValue(propValue, property.PropertyType));
                }
            }
            return instance;
        }
        
        return PocoPathHelper.ConvertValue(value, targetType);
    }
}